{"name":"Exemplo do padrão Strategy em C++","tagline":"Exemplo em C++ do uso do padrão de projeto Strategy","body":"## Descrição do padrão\r\n\r\nA ideia do padrão é encapsular diferentes comportamentos e dinamicamente associá-los a uma implementação.\r\n\r\nEm outras palavras, a intenção é definir famílias de algoritmos e fazê-los intercambiáveis. O padrão deixa que o algoritmo varie independentemente do cliente que o usam. E é possível ainda mudar o algoritmo em tempo de execução.\r\n\r\nA figura abaixo mostra como o padrão é comumente implementado.\r\n\r\n![Estrutura do Strategy](http://sourcemaking.com/files/v2/content/patterns/Strategy1-2x.png)\r\n\r\nUma das grandes vantagens do padrão é o baixo acoplamento, pois a implementação dos algoritmo pode variar sem qualquer alteração necessária nos clientes.\r\n\r\nO principal princípio usado nesse padrão é \"programe para interfaces, e não para implementações.\r\n\r\n## Explicação do exemplo\r\n\r\nO exemplo trata um exemplo básico de uma calculadora. Com apenas algumas poucas operações implementadas, apenas para ilustrar o padrão. \r\n\r\nA classe `Strategy` define uma interface que será implementada por diferentes operações de uma calculadora (como adição, multiplicação e etc). Assim a classe `Strategy` define uma família de comportamentos.\r\n\r\n**Strategy.h:**\r\n```cpp\r\nclass Strategy\r\n{\r\npublic:\r\n    Strategy();\r\n    virtual int execute(const int a, const int b) const = 0;\r\n    virtual ~Strategy();\r\n};\r\n```\r\n\r\n**Strategy.cpp:**\r\n```cpp\r\n#include \"Strategy.h\"\r\n\r\nStrategy::Strategy() { }\r\nStrategy::~Strategy() { }\r\n```\r\n\r\nComo é possível notar, o método `execute(..)` da classe `Strategy` não é implementado, pois essa responsabilidade é entregue as suas subclasses. Como por exemplo, a classe `Add`:\r\n\r\n**Add.h**\r\n```cpp\r\n#include \"Strategy.h\"\r\n\r\nclass Add : public Strategy\r\n{\r\npublic:\r\n    Add();\r\n    virtual int execute(const int a, const int b) const;\r\n    virtual ~Add();\r\n};\r\n```\r\n**Add.cpp**\r\n```cpp\r\n#include \"Add.h\"\r\n#include <iostream>\r\n\r\nAdd::Add() { }\r\nint Add::execute(const int a, const int b) const\r\n{\r\n    std::cout << \"Called Add's execute()\" << std::endl;\r\n    return a + b;\r\n}\r\nAdd::~Add() { }\r\n```\r\n\r\nAssim, a classe `Add` implementa o método `execute(..)` para executar o seu algoritmo específico. No caso, imprimir uma pequena frase, e retornar a soma dos dois parâmetros recebidos.\r\n\r\nDá mesma forma que a classe `Add`, as classes `Subtract` e `Multiply` também herdam da classe `Strategy` e implementam o método `execute(..)` do seu modo específico. E como as operações compartilham essa interface em comum (a classe `Strategy`), podem ser dinamicamente utilizados por qualquer cliente que use a classe `Strategy`.\r\n\r\nIsso pode ser observado na classe `Context`, que tem um atributo chamado `strategy` que define a operação que está sendo atualmente usada numa determinada instância. E quando o método `executeStrategy(..)` for chamado, ele executará a operação da estratégia atual, chamando `strategy.execute(..)`.\r\n\r\n**Context.h:**\r\n```cpp\r\nclass Strategy;\r\n\r\nclass Context\r\n{\r\nprivate:\r\n    const Strategy * const strategy;\r\npublic:\r\n    Context(Strategy* strategy);\r\n    int executeStrategy(const int a, const int b) const;\r\n    virtual ~Context();\r\n};\r\n```\r\n\r\n**Context.cpp:**\r\n```cpp\r\nContext::Context(Strategy* strategy) : strategy(strategy) { }\r\nint Context::executeStrategy(const int a, const int b) const\r\n{\r\n    return this->strategy->execute(a, b);\r\n}\r\nContext::~Context()\r\n{\r\n    this->strategy->~Strategy();\r\n}\r\n```\r\n\r\nVeja que é impossível prever que operação será realizada quando o método `executeStrategy(..)` da classe `Context` for invocado, pois a estratégia (isto é, a operação) só será definida na construção de cada objeto. Portanto, é definida em tempo de execução.\r\n\r\nPor fim, temos o método `main` que exemplifica o uso das classes criadas.\r\n\r\n**main.cpp:**\r\n```cpp\r\n#include <cstdlib>\r\n#include <iostream>\r\n\r\n#include \"Context.h\"\r\n#include \"Add.h\"\r\n#include \"Subtract.h\"\r\n#include \"Multiply.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char** argv)\r\n{\r\n    // Declara alguns valores.\r\n    const Context* context;\r\n    const int a = 3;\r\n    const int b = 2;\r\n\r\n    // Cria um contexto, com a operação de adicionar,\r\n    // executa a operação, e destrói o objeto.\r\n    context = new Context(new Add());\r\n    const int resultA = context->executeStrategy(a, b);\r\n    context->~Context();\r\n\r\n\t// Cria um contexto, com a operação de subtrair,\r\n\t// executa a operação, e destrói o objeto.\r\n    context = new Context(new Subtract());\r\n    const int resultB = context->executeStrategy(a, b);\r\n    context->~Context();\r\n\r\n\t// Cria um contexto, com a operação de multiplicar,\r\n\t// executa a operação, e destrói o objeto.\r\n    context = new Context(new Multiply());\r\n    const int resultC = context->executeStrategy(a, b);\r\n    context->~Context();\r\n\r\n    // Imprime os resultados obtidos.\r\n    cout << \"Result A: \" << resultA << endl;\r\n    cout << \"Result B: \" << resultB << endl;\r\n    cout << \"Result C: \" << resultC << endl;\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n## Alunos\r\n- Lucas Possatti (@possatti)\r\n- Phillipe Alcantara (@paflopes)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}