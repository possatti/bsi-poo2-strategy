{"name":"Exemplo do padrão Strategy em C++","tagline":"Exemplo em C++ do uso do padrão de projeto Strategy","body":"## Descrição do padrão\r\n\r\nA ideia do padrão é encapsular diferentes comportamentos e dinamicamente associá-los a uma implementação.\r\n\r\nEm outras palavras, a intenção é definir famílias de algoritmos e fazê-los intercambiáveis. O padrão deixa que o algoritmo varie independentemente do cliente que o usam. E é possível ainda mudar o algoritmo em tempo de execução.\r\n\r\nA figura abaixo mostra como o padrão é comumente implementado.\r\n\r\n![Estrutura do Strategy](http://sourcemaking.com/files/v2/content/patterns/Strategy1-2x.png)\r\n\r\nUma das grandes vantagens do padrão é o baixo acoplamento, pois a implementação dos algoritmo pode variar sem qualquer alteração necessária nos clientes.\r\n\r\nO principal princípio usado nesse padrão é \"programe para interfaces, e não para implementações.\r\n\r\n## Explicação do exemplo\r\n\r\nO exemplo trata um exemplo básico de uma calculadora. Com apenas algumas poucas operações implementadas, apenas para ilustrar o padrão. \r\n\r\nA classe `Strategy` define uma interface que será implementada por diferentes operações de uma calculadora (como adição, multiplicação e etc). Assim a classe `Strategy` define uma família de comportamentos.\r\nStrategy.h:\r\n'''cpp\r\nclass Strategy\r\n{\r\npublic:\r\n    Strategy();\r\n    virtual int execute(const int a, const int b) const = 0;\r\n    virtual ~Strategy();\r\n};\r\n'''\r\n\r\nEsses comportamentos por sua vez, serão usados pela classe `Context`, que tem um atributo chamado `strategy` que define a operação que está sendo atualmente usada. E quando o método `executeStrategy(..)` for chamado, ele executará a operação da estratégia atual.\r\n\r\n## Alunos\r\n- Lucas Possatti (@possatti)\r\n- Phillipe Alcantara (@paflopes)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}